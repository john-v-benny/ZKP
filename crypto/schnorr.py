"""
Schnorr Zero-Knowledge Proof Protocol Implementation.

Protocol Overview:
1. Prover wants to prove knowledge of private key x without revealing it
2. Commitment: Prover generates random r, computes t = g^r mod p
3. Challenge: Verifier sends random challenge c
4. Response: Prover computes s = r + c*x mod q
5. Verification: Verifier checks if g^s = t * y^c mod p
"""

from typing import Tuple, Dict
from .utils import CryptoUtils


class SchnorrZKP:
    """Schnorr Zero-Knowledge Proof protocol implementation."""
    
    def __init__(self):
        self.p, self.g, self.q = CryptoUtils.get_parameters()
    
    def generate_commitment(self) -> Tuple[int, int]:
        """
        Generate commitment for ZKP (Prover step 1).
        
        Returns:
            Tuple of (random r, commitment t = g^r mod p)
        """
        # Generate random r in range [1, q-1]
        r = CryptoUtils.generate_random_in_range(self.q)
        
        # Compute commitment t = g^r mod p
        t = CryptoUtils.mod_exp(self.g, r, self.p)
        
        return r, t
    
    def generate_challenge(self, bits: int = 256) -> int:
        """
        Generate random challenge (Verifier step).
        
        Args:
            bits: Number of bits for the challenge
            
        Returns:
            Random challenge c
        """
        # Generate random challenge
        c = CryptoUtils.generate_random(bits)
        # Ensure it's within valid range
        c = c % self.q
        return c
    
    def generate_response(self, r: int, c: int, private_key: int) -> int:
        """
        Generate response to challenge (Prover step 2).
        
        Args:
            r: Random value from commitment
            c: Challenge from verifier
            private_key: Private key x
            
        Returns:
            Response s = (r + c*x) mod q
        """
        # Compute s = r + c*x mod q
        s = (r + c * private_key) % self.q
        return s
    
    def verify_proof(self, t: int, s: int, c: int, public_key: int) -> bool:
        """
        Verify the ZKP proof (Verifier step).
        
        Checks if: g^s = t * y^c mod p
        
        Args:
            t: Commitment from prover
            s: Response from prover
            c: Challenge sent to prover
            public_key: Public key y
            
        Returns:
            True if proof is valid, False otherwise
        """
        # Compute left side: g^s mod p
        left = CryptoUtils.mod_exp(self.g, s, self.p)
        
        # Compute right side: t * y^c mod p
        y_c = CryptoUtils.mod_exp(public_key, c, self.p)
        right = (t * y_c) % self.p
        
        # Verify equality
        return left == right
    
    def create_proof(self, private_key: int, challenge: int) -> Dict[str, int]:
        """
        Create a complete ZKP proof given a challenge.
        
        Args:
            private_key: Private key x
            challenge: Challenge c from verifier
            
        Returns:
            Dictionary with commitment t and response s
        """
        # Generate commitment
        r, t = self.generate_commitment()
        
        # Generate response
        s = self.generate_response(r, challenge, private_key)
        
        return {
            'commitment': t,
            'response': s
        }
    
    def verify_complete_proof(self, proof: Dict[str, int], challenge: int, 
                             public_key: int) -> bool:
        """
        Verify a complete ZKP proof.
        
        Args:
            proof: Dictionary with commitment and response
            challenge: Challenge c that was sent
            public_key: Public key y
            
        Returns:
            True if proof is valid, False otherwise
        """
        t = proof['commitment']
        s = proof['response']
        return self.verify_proof(t, s, challenge, public_key)
    
    def create_non_interactive_proof(self, private_key: int, public_key: int, 
                                    message: str = "") -> Dict[str, int]:
        """
        Create a non-interactive ZKP proof using Fiat-Shamir heuristic.
        Challenge is generated by hashing the commitment and message.
        
        Args:
            private_key: Private key x
            public_key: Public key y
            message: Optional message to include in proof
            
        Returns:
            Dictionary with commitment t, response s, and challenge c
        """
        # Generate commitment
        r, t = self.generate_commitment()
        
        # Generate challenge using hash (Fiat-Shamir)
        c = CryptoUtils.hash_to_int(t, public_key, message) % self.q
        
        # Generate response
        s = self.generate_response(r, c, private_key)
        
        return {
            'commitment': t,
            'response': s,
            'challenge': c
        }
    
    def verify_non_interactive_proof(self, proof: Dict[str, int], 
                                    public_key: int, message: str = "") -> bool:
        """
        Verify a non-interactive ZKP proof.
        
        Args:
            proof: Dictionary with commitment, response, and challenge
            public_key: Public key y
            message: Optional message that was included
            
        Returns:
            True if proof is valid, False otherwise
        """
        t = proof['commitment']
        s = proof['response']
        c = proof['challenge']
        
        # Verify challenge was computed correctly
        expected_c = CryptoUtils.hash_to_int(t, public_key, message) % self.q
        if c != expected_c:
            return False
        
        # Verify the proof
        return self.verify_proof(t, s, c, public_key)
